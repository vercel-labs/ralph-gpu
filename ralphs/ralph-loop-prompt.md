# Ralph Loop Implementation Guide

Implement the feature the user is requesting by creating a ralph-loop script using the `@ralph/agent-loop` package.

## What is Ralph Loop?

Ralph Loop is an autonomous AI agent library that runs an AI model in a loop with tools until a task is completed. It includes:

- **Default Tools**: bash, file operations (read/write), process management, browser automation
- **Progress Tracking**: Automatic iteration, cost, and token tracking
- **Stuck Detection**: Identifies repetitive patterns, error loops, oscillation, and no-progress situations
- **Trace Mode**: Captures detailed execution data to NDJSON files for analysis
- **Built-in Rules**: `brainRule`, `trackProgressRule`, `visualCheckRule`, `minimalChangesRule`, etc.

## Ralph Script Structure

Create a new numbered folder in `ralphs/` (e.g., `[number]-feature-name/`) with:

```
[number]-feature-name/
‚îú‚îÄ‚îÄ index.ts           # Main script with LoopAgent configuration
‚îú‚îÄ‚îÄ package.json       # Package definition
‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config
‚îú‚îÄ‚îÄ .env              # API keys (copy from another ralph folder)
‚îú‚îÄ‚îÄ .progress.md      # Generated by agent during execution
‚îî‚îÄ‚îÄ .brain/           # Generated by agent if using brainRule
    ‚îú‚îÄ‚îÄ index.md
    ‚îî‚îÄ‚îÄ conventions.md
```

### package.json

```json
{
  "name": "[number]-feature-name",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "tsx index.ts"
  },
  "dependencies": {
    "@ai-sdk/gateway": "^3.0.11",
    "@ai-sdk/openai-compatible": "^1.0.0",
    "@ralph/agent-loop": "workspace:*",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3"
  }
}
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["*.ts"]
}
```

## Script Template

```typescript
/**
 * XX-feature-name: Brief description
 */

import "dotenv/config";
import { LoopAgent, brainRule, trackProgressRule, minimalChangesRule, completionRule, visualCheckRule, processManagementRule } from "@ralph/agent-loop";
import * as fs from "fs/promises";

// Configuration from environment
const AI_GATEWAY_API_KEY = process.env.AI_GATEWAY_API_KEY;
const AGENT_MODEL = "google/gemini-3-flash"
const PROJECT_ROOT = process.env.PROJECT_ROOT || "../..";

if (!AI_GATEWAY_API_KEY) {
  console.error("‚ùå Missing AI_GATEWAY_API_KEY");
  process.exit(1);
}

const DEBUG = process.env.DEBUG === "true" || process.argv.includes("--debug");

const TASK = \`
# Task: [Feature Name]

## Working Directory & Navigation
This script is running from: \${process.cwd()}
Project root is: \${PROJECT_ROOT}

### Repository Structure
\\\`\\\`\\\`
[Describe the key folders and their purpose, for example:]
ralph-gpu/                    (project root)
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ core/                 (main WebGPU library package)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/              (library source code)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tests/            (library tests)
‚îÇ   ‚îî‚îÄ‚îÄ ralph/                (agent-loop package)
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îî‚îÄ‚îÄ examples/             (Next.js app with examples)
‚îÇ       ‚îî‚îÄ‚îÄ app/              (example pages)
‚îî‚îÄ‚îÄ ralphs/
    ‚îî‚îÄ‚îÄ XX-feature-name/      (‚Üê YOU ARE HERE - this script's folder)
\\\`\\\`\\\`

### Navigation Instructions
- To access project files: use relative paths from \${PROJECT_ROOT}
- To access this script's files: use paths relative to \${process.cwd()}
- Example: To edit core library: \`cd \${PROJECT_ROOT}/packages/core\`
- Example: To update progress: \`cat >> \${process.cwd()}/.progress.md\`

## ‚ö†Ô∏è CRITICAL: CHECK EXISTING PROGRESS FIRST ‚ö†Ô∏è
**BEFORE doing ANY work, you MUST:**
1. Check if .progress.md exists: \`cat \${process.cwd()}/.progress.md 2>/dev/null || echo "No progress file"\`
2. Check if .brain/ exists: \`ls \${process.cwd()}/.brain/ 2>/dev/null && cat \${process.cwd()}/.brain/index.md 2>/dev/null || echo "No brain"\`
3. Check what files already exist in the target locations

**If progress exists, CONTINUE from where you left off. DO NOT restart from scratch!**
**If files already exist, skip creating them and move to the NEXT incomplete task.**

## Progress Tracking Rules
- ONLY create .progress.md if it doesn't exist
- ONLY update .progress.md by APPENDING or updating checkboxes, never recreate from scratch
- Read your previous progress before each action to avoid repeating work
- If a task is already marked [x] complete, skip it and move to the next one

## Context
[Explain the current state and what needs to be implemented]

## Acceptance Criteria (ALL MUST BE MET)

### 1. [Category]
- [ ] Specific requirement
- [ ] Another requirement

### 2. [Category]
- [ ] Specific requirement

## Implementation Guide
[Provide step-by-step instructions with code examples]

## Browser Automation
‚ö†Ô∏è **CRITICAL**: Browser automation ALWAYS runs in headless mode by default.
- Do NOT set headless: false
- Do NOT write custom Playwright scripts for interaction testing
- Visual verification (screenshot + no console errors) is SUFFICIENT
- After ONE successful visual verification ‚Üí call done() immediately

## Testing Commands
\\\`\\\`\\\`bash
cd \${PROJECT_ROOT}
pnpm build
pnpm test
\\\`\\\`\\\`

## üö® FIRST ACTION - ALWAYS DO THIS FIRST üö®
Your VERY FIRST action must be to check existing progress and what already exists.
Based on what already exists, SKIP completed tasks and proceed to the next incomplete one.
\`;

// Verification functions
async function checkFeatureImplemented(): Promise<boolean> {
  // Implement checks
  return false;
}

async function main() {
  const startTime = Date.now();

  const agent = new LoopAgent({
    model: AGENT_MODEL,
    trace: true,  // Always enable traces
    task: TASK,
    // ALWAYS include completionRule to prevent infinite loops
    // For UI tasks, also include visualCheckRule and processManagementRule
    rules: [brainRule, trackProgressRule, minimalChangesRule, completionRule, visualCheckRule, processManagementRule],
    debug: DEBUG,
    limits: {
      maxIterations: 30,
      maxCost: 15.0,
      timeout: "60m",
    },
    onUpdate: (status) => {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(
        \`[\${elapsed}s] Iteration \${status.iteration} | State: \${status.state} | Cost: $\${status.cost.toFixed(4)}\`
      );
    },
    onStuck: async (ctx) => {
      console.log(\`\\n‚ö†Ô∏è Agent stuck: \${ctx.reason}\`);
      return "Try a different approach. Update .progress.md with what you tried.";
    },
    onError: (error) => {
      console.error(\`\\n‚ùå Error: \${error.message}\`);
    },
  });

  console.log("üöÄ Starting agent...\\n");

  const result = await agent.run();

  console.log("\\nüìä Results");
  console.log(\`‚úÖ Success: \${result.success}\`);
  console.log(\`üîÑ Iterations: \${result.iterations}\`);
  console.log(\`üí∞ Cost: $\${result.cost.toFixed(4)}\`);
  console.log(\`‚è±Ô∏è Duration: \${(result.elapsed / 1000).toFixed(1)}s\`);

  // Run verification
  const passed = await checkFeatureImplemented();
  console.log(\`\\n\${passed ? "üéâ All checks passed!" : "‚ö†Ô∏è Some checks failed"}\`);

  if (!result.success) {
    console.error(\`\\n‚ùå Agent failed: \${result.reason}\`);
    process.exit(1);
  }

  process.exit(passed ? 0 : 1);
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
```

## Planning & Task Definition

1. **Break down the work**: Define small, focused tasks - run one ralph per task
2. **Track progress**: Update your original plan file at project root
3. **Write detailed TASK strings** with:

   - **Repository structure diagram**: Show the project layout and where this script lives
   - **Navigation instructions**: Explain how to access different parts of the codebase
   - Clear context about current state
   - Specific acceptance criteria as checkboxes
   - Step-by-step implementation guide with code examples
   - File paths and working directories clearly specified (with examples)
   - Reminder to update .progress.md frequently
   - Testing commands to validate the work

4. **Create verification functions**: Write TypeScript functions that check if acceptance criteria are met

## Available Rules

Include relevant rules in your LoopAgent configuration:

- `brainRule` - Use `.brain/` folder for persistent knowledge
- `trackProgressRule` - Track progress in `.progress.md`
- `visualCheckRule` - **USE FOR UI TASKS**: Visually verify UI changes with browser (always headless)
- `testFirstRule` - Run tests before and after changes
- `minimalChangesRule` - Keep changes surgical and focused
- `explorationRule` - Explore codebase before editing
- `gitCheckpointRule` - Commit after each change
- `debugRule` - Systematic debugging approach
- `completionRule` - **CRITICAL**: Ensures agent calls `done()` when task is complete (prevents infinite loops)
- `processManagementRule` - **NEW**: Prevents spawning multiple dev servers, manages processes efficiently

### ALWAYS Include These Rules for UI Tasks:

```typescript
rules: [
  brainRule,
  trackProgressRule,
  minimalChangesRule,
  completionRule,
  visualCheckRule,
  processManagementRule,
];
```

### Browser Validation (IMPORTANT)

**For any task that creates or modifies UI components, the ralph MUST validate with a real browser:**

1. **Include `visualCheckRule` and `processManagementRule`** in the rules array for UI tasks
2. **Add browser validation steps** to the TASK acceptance criteria:
   ```
   ### Browser Validation (REQUIRED)
   - [ ] Start dev server: `pnpm dev` (check listProcesses first, reuse if running)
   - [ ] Navigate to the page in headless browser
   - [ ] Take screenshot to verify rendering
   - [ ] Check browser console for errors
   - [ ] If screenshot shows UI working with no errors ‚Üí DONE
   ```
3. **ALWAYS run in headless mode** - the browser MUST be headless (default behavior)

**What counts as "verified":**

- Screenshot shows the expected UI elements
- No console errors
- The main visual output looks correct

**What does NOT need verification in headless mode:**

- Keyboard shortcuts (unreliable in headless Playwright)
- Hover states and animations
- Complex user interactions

**After ONE successful visual verification ‚Üí call done() immediately**

**Examples of tasks that REQUIRE browser validation:**

- Creating example pages (like `debug-profiler/page.tsx`)
- Modifying UI components
- Adding visual features or effects
- Fixing rendering bugs

**Do NOT skip browser validation** - `pnpm build` passing does NOT mean the UI actually works!

### CRITICAL: Avoid Re-Verification Loops

A common failure pattern is the agent getting stuck re-verifying the same thing:

1. Takes screenshot ‚Üí UI looks good ‚Üí doesn't call done()
2. Next iteration: reads same files ‚Üí takes same screenshot ‚Üí doesn't call done()
3. Repeats forever, wasting tokens

**To prevent this, the TASK should include:**

```
## Completion Criteria
After visual verification passes (screenshot shows UI working, no errors):
1. Update .progress.md to mark all items [x] complete
2. Call done() IMMEDIATELY
3. Do NOT re-read files or take more screenshots
```

## Execution Workflow

1. **Setup environment**:

   ```bash
   cd ralphs/[number]-feature-name
   cp ../28-previous-task/.env .env
   ```

2. **Run in background terminal**:

   ```bash
   pnpm tsx index.ts > .ralph-output.log 2>&1 &
   ```

3. **Monitor progress** (check periodically):

   ```bash
   # Initial checks: every 60 seconds
   sleep 60 && tail -n 50 .ralph-output.log && cat .progress.md

   # Later checks: every 3 minutes
   sleep 180 && tail -n 50 .ralph-output.log && cat .progress.md
   ```

4. **View traces** (for debugging):

   ```bash
   # Real-time trace monitoring
   tail -f .traces/trace-*.ndjson | jq .

   # Check stuck events
   cat .traces/trace-*.ndjson | jq 'select(.type == "stuck_detected")'
   ```

5. **Handle completion**:
   - ‚úÖ **Task passed**: **ALWAYS commit the changes immediately** before moving to the next ralph:
     ```bash
     cd $PROJECT_ROOT
     git add -A
     git commit -m "feat: brief description of what the ralph accomplished"
     ```
   - ‚ùå **Task failed**: Follow this recovery process:
     1. **Reset ALL uncommitted changes**: `git checkout -- . && git clean -fd` (remove all changes from the failed ralph)
     2. **Analyze why it failed**: Check `.ralph-output.log`, `.progress.md`, test output
     3. **Create a NEW ralph** with improved instructions based on learnings
     4. **Try a different model**: If `google/gemini-3-flash` failed, use `anthropic/claude-opus-4.5`
     5. **Never manually fix** the ralph's code - let the new ralph do it with better instructions

## Best Practices

- **COMMIT AFTER EVERY SUCCESSFUL RALPH**: Always `git add -A && git commit` immediately after a ralph completes successfully. Don't accumulate uncommitted changes across multiple ralphs.
- **BROWSER VALIDATION FOR UI TASKS**: If the ralph creates or modifies any UI (pages, components, visual features), include `visualCheckRule` and add browser validation to acceptance criteria. Build passing ‚â† UI working!
- **ALWAYS HEADLESS BROWSER**: Browser automation MUST run in headless mode. The agent should NEVER launch visible browser windows unless explicitly required by the task.
- **INCLUDE completionRule**: Always include `completionRule` to prevent infinite iteration loops.
- **INCLUDE processManagementRule**: For UI tasks, include `processManagementRule` to prevent spawning multiple dev servers.
- **Repository structure clarity**: Always include a visual diagram of the repo structure in the TASK string so the LLM understands where it is and how to navigate
- **CHECK EXISTING PROGRESS FIRST**: The TASK must instruct the ralph to check for existing `.progress.md` and `.brain/` files BEFORE doing any work. This prevents the agent from restarting tasks from scratch each iteration. Include a "FIRST ACTION" section that reads existing state and checks if files already exist.
- **Progress tracking**: Ralph tracks progress in its own folder (`.progress.md`, `.brain/`)
- **Don't overwrite progress**: Instruct the ralph to APPEND to `.progress.md` rather than recreating it. Only create these files if they don't exist. If tasks are already marked complete, skip them.
- **Don't pre-create state files**: Let the agent create `.brain/` and `.progress.md` - provide templates in TASK string
- **Always enable traces**: Use `trace: true` for debugging and analysis
- **Only enable debug for issues**: Use `debug: false` by default, enable only when troubleshooting the runner itself
- **One ralph at a time**: Create and run ralphs sequentially, not in parallel. This allows you to pivot the scope of your larger goal based on results and adapt your approach between tasks
- **Verification is critical**: Always include TypeScript verification functions that run after completion
- **Be specific in TASK**: Include exact file paths, working directories, code examples, and step-by-step navigation instructions
- **Documentation**: Ask ralphs to update docs, tests, and cursor rules as needed
- **Keep executing until completion**: Continue working through all tasks in your plan until the entire long-term goal is achieved. Don't stop after individual ralphs complete. Keep running sleeps commands to check progress.
- **Progress tracking**: Never edit the .progress.md file yourself, instruct the ralph LLM to do it.

## Common Anti-Patterns to Avoid

These patterns cause ralphs to waste tokens and get stuck in loops:

### 1. Re-Verification Loop

**Problem**: Agent keeps re-verifying completed work instead of calling `done()`

```
Iter 1: Verify UI ‚Üí works ‚Üí doesn't call done
Iter 2: Verify UI ‚Üí works ‚Üí doesn't call done
... repeats forever
```

**Solution**: TASK should explicitly state: "After ONE successful verification, call done() immediately"

### 2. Multiple Dev Servers

**Problem**: Agent starts `pnpm dev` every iteration, spawning servers on ports 3000, 3001, 3002...
**Solution**: Include `processManagementRule` and instruct agent to check `listProcesses()` first

### 3. Redundant File Reading

**Problem**: Agent re-reads the same files every iteration
**Solution**: TASK should state: "Do NOT re-read files you just wrote or verified"

### 4. Flaky Interaction Testing

**Problem**: Agent writes Playwright scripts to test keyboard shortcuts in headless mode (unreliable)
**Solution**: TASK should state: "Visual verification (screenshot + no errors) is SUFFICIENT. Do NOT test keyboard shortcuts in headless mode"

### 5. Never Calling done()

**Problem**: Agent completes all tasks but never calls `done()`
**Solution**: Include `completionRule` and add explicit completion criteria to TASK:

```
## When to call done()
If .progress.md shows ALL items [x] complete AND visual verification passed:
‚Üí Call done({ summary: "..." }) IMMEDIATELY
```

## CRITICAL: Orchestrator Agent Rules

**YOU (the orchestrator agent running in Cursor) MUST follow these rules when executing ralphs:**

### DO NOT Create Automation Scripts

**NEVER create scripts like:**

- `run-all-phase2.sh`
- `wait-and-continue.sh`
- `run-remaining-ralphs.sh`
- Any script that automatically chains or batches ralph execution

**Why?** You need to review results after each ralph and potentially adjust your plan. Automation removes your ability to adapt.

### Execute ONE Ralph at a Time

1. **Create ONE ralph** for the immediate next task
2. **Run it in background**: `pnpm start > .ralph-output.log 2>&1 &`
3. **Monitor it yourself** using `sleep` + check commands (do NOT delegate monitoring to scripts)
4. **Wait for completion** - keep checking every 1-3 minutes
5. **Review results** thoroughly
6. **Update the plan file** with findings
7. **Commit changes** if successful
8. **Then and only then** create the next ralph

### You Are the Orchestrator

As the orchestrator agent, YOU must:

- **Actively monitor** each ralph using sleep commands and log checks
- **Stay in the loop** - don't hand off control to automation scripts
- **Review and adapt** after each ralph completes
- **Update plan documents** yourself based on results
- **Make decisions** about whether to proceed, retry, or change approach

### Monitoring Pattern

```bash
# Start ralph in background
cd ralphs/[number]-feature-name
pnpm start > .ralph-output.log 2>&1 &

# Monitor every 60-180 seconds (YOU run these, don't script them)
sleep 60 && tail -n 30 .ralph-output.log && cat .progress.md

# Keep checking until ralph completes
sleep 120 && tail -n 30 .ralph-output.log

# When done, review results
cat .ralph-output.log | tail -n 50
cat .progress.md
```

### After Each Ralph Completes

1. **Check results**: Did it succeed? What was created/changed?
2. **Verify changes**: Are the changes correct? Run tests if applicable
3. **Update plan**: Add notes, mark items complete, document findings
4. **Commit**: `git add -A && git commit -m "feat: description"`
5. **Decide next step**: Based on results, create the next ralph OR adjust approach

### Example Workflow

```
1. Read plan, identify first task
2. Create ralph 45 for "uniforms tests"
3. Run ralph 45, monitor with sleep commands
4. Ralph 45 completes - review output
5. Update plan with findings from ralph 45
6. Commit ralph 45 changes
7. Based on results, create ralph 46 for "time controls tests"
8. Run ralph 46, monitor with sleep commands
9. ... repeat until plan is complete
```

**Remember: You are the brain coordinating the work. Don't automate yourself out of the loop!**
