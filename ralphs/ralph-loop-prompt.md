# Ralph Loop Implementation Guide

Implement the feature the user is requesting by creating a ralph-loop script using the `@ralph/agent-loop` package.

## What is Ralph Loop?

Ralph Loop is an autonomous AI agent library that runs an AI model in a loop with tools until a task is completed. It includes:

- **Default Tools**: bash, file operations (read/write), process management, browser automation
- **Progress Tracking**: Automatic iteration, cost, and token tracking
- **Stuck Detection**: Identifies repetitive patterns, error loops, oscillation, and no-progress situations
- **Trace Mode**: Captures detailed execution data to NDJSON files for analysis
- **Built-in Rules**: `brainRule`, `trackProgressRule`, `visualCheckRule`, `minimalChangesRule`, etc.

## Ralph Script Structure

Create a new numbered folder in `ralphs/` (e.g., `[number]-feature-name/`) with:

```
[number]-feature-name/
‚îú‚îÄ‚îÄ index.ts           # Main script with LoopAgent configuration
‚îú‚îÄ‚îÄ package.json       # Package definition
‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config
‚îú‚îÄ‚îÄ .env              # API keys (copy from another ralph folder)
‚îú‚îÄ‚îÄ .progress.md      # Generated by agent during execution
‚îî‚îÄ‚îÄ .brain/           # Generated by agent if using brainRule
    ‚îú‚îÄ‚îÄ index.md
    ‚îî‚îÄ‚îÄ conventions.md
```

### package.json

```json
{
  "name": "[number]-feature-name",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "start": "tsx index.ts"
  },
  "dependencies": {
    "@ai-sdk/gateway": "^3.0.11",
    "@ai-sdk/openai-compatible": "^1.0.0",
    "@ralph/agent-loop": "workspace:*",
    "dotenv": "^16.4.5"
  },
  "devDependencies": {
    "@types/node": "^20.11.0",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3"
  }
}
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["*.ts"]
}
```

## Script Template

```typescript
/**
 * XX-feature-name: Brief description
 */

import "dotenv/config";
import { LoopAgent, brainRule, trackProgressRule, minimalChangesRule } from "@ralph/agent-loop";
import * as fs from "fs/promises";

// Configuration from environment
const AI_GATEWAY_API_KEY = process.env.AI_GATEWAY_API_KEY;
const AGENT_MODEL = process.env.AGENT_MODEL || "anthropic/claude-sonnet-4-20250514";
const PROJECT_ROOT = process.env.PROJECT_ROOT || "../..";

if (!AI_GATEWAY_API_KEY) {
  console.error("‚ùå Missing AI_GATEWAY_API_KEY");
  process.exit(1);
}

const DEBUG = process.env.DEBUG === "true" || process.argv.includes("--debug");

const TASK = \`
# Task: [Feature Name]

## Working Directory & Navigation
This script is running from: \${process.cwd()}
Project root is: \${PROJECT_ROOT}

### Repository Structure
\\\`\\\`\\\`
[Describe the key folders and their purpose, for example:]
ralph-gpu/                    (project root)
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ core/                 (main WebGPU library package)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/              (library source code)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tests/            (library tests)
‚îÇ   ‚îî‚îÄ‚îÄ ralph/                (agent-loop package)
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îî‚îÄ‚îÄ examples/             (Next.js app with examples)
‚îÇ       ‚îî‚îÄ‚îÄ app/              (example pages)
‚îî‚îÄ‚îÄ ralphs/
    ‚îî‚îÄ‚îÄ XX-feature-name/      (‚Üê YOU ARE HERE - this script's folder)
\\\`\\\`\\\`

### Navigation Instructions
- To access project files: use relative paths from \${PROJECT_ROOT}
- To access this script's files: use paths relative to \${process.cwd()}
- Example: To edit core library: \`cd \${PROJECT_ROOT}/packages/core\`
- Example: To update progress: \`cat >> \${process.cwd()}/.progress.md\`

## CRITICAL: Update Progress
After EVERY significant action, update .progress.md in this folder:
- Path: \${process.cwd()}/.progress.md
- Log what you did with timestamp
- Update checkboxes for acceptance criteria
- Document any errors

## Context
[Explain the current state and what needs to be implemented]

## Acceptance Criteria (ALL MUST BE MET)

### 1. [Category]
- [ ] Specific requirement
- [ ] Another requirement

### 2. [Category]
- [ ] Specific requirement

## Implementation Guide
[Provide step-by-step instructions with code examples]

## Browser Automation
‚ö†Ô∏è **CRITICAL**: If this task requires browser automation, ALWAYS use headless mode:
- Run all browser tests and visual checks in headless mode
- Configure browser with \`headless: true\`
- This improves performance and reliability

## Testing Commands
\\\`\\\`\\\`bash
cd \${PROJECT_ROOT}
pnpm build
pnpm test
\\\`\\\`\\\`
\`;

// Verification functions
async function checkFeatureImplemented(): Promise<boolean> {
  // Implement checks
  return false;
}

async function main() {
  const startTime = Date.now();

  const agent = new LoopAgent({
    model: "google/gemini-3-flash", // use this one or "anthropic/claude-sonnet-4.5" if gemini didnt solve the isuse the first time
    trace: true,  // Always enable traces
    task: TASK,
    rules: [brainRule, trackProgressRule, minimalChangesRule],
    debug: DEBUG,
    limits: {
      maxIterations: 30,
      maxCost: 15.0,
      timeout: "60m",
    },
    onUpdate: (status) => {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      console.log(
        \`[\${elapsed}s] Iteration \${status.iteration} | State: \${status.state} | Cost: $\${status.cost.toFixed(4)}\`
      );
    },
    onStuck: async (ctx) => {
      console.log(\`\\n‚ö†Ô∏è Agent stuck: \${ctx.reason}\`);
      return "Try a different approach. Update .progress.md with what you tried.";
    },
    onError: (error) => {
      console.error(\`\\n‚ùå Error: \${error.message}\`);
    },
  });

  console.log("üöÄ Starting agent...\\n");

  const result = await agent.run();

  console.log("\\nüìä Results");
  console.log(\`‚úÖ Success: \${result.success}\`);
  console.log(\`üîÑ Iterations: \${result.iterations}\`);
  console.log(\`üí∞ Cost: $\${result.cost.toFixed(4)}\`);
  console.log(\`‚è±Ô∏è Duration: \${(result.elapsed / 1000).toFixed(1)}s\`);

  // Run verification
  const passed = await checkFeatureImplemented();
  console.log(\`\\n\${passed ? "üéâ All checks passed!" : "‚ö†Ô∏è Some checks failed"}\`);

  if (!result.success) {
    console.error(\`\\n‚ùå Agent failed: \${result.reason}\`);
    process.exit(1);
  }

  process.exit(passed ? 0 : 1);
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
```

## Planning & Task Definition

1. **Break down the work**: Define small, focused tasks - run one ralph per task
2. **Track progress**: Update your original plan file at project root
3. **Write detailed TASK strings** with:

   - **Repository structure diagram**: Show the project layout and where this script lives
   - **Navigation instructions**: Explain how to access different parts of the codebase
   - Clear context about current state
   - Specific acceptance criteria as checkboxes
   - Step-by-step implementation guide with code examples
   - File paths and working directories clearly specified (with examples)
   - Reminder to update .progress.md frequently
   - Testing commands to validate the work

4. **Create verification functions**: Write TypeScript functions that check if acceptance criteria are met

## Available Rules

Include relevant rules in your LoopAgent configuration:

- `brainRule` - Use `.brain/` folder for persistent knowledge
- `trackProgressRule` - Track progress in `.progress.md`
- `visualCheckRule` - Visually verify UI changes with browser (always run in headless mode)
- `testFirstRule` - Run tests before and after changes
- `minimalChangesRule` - Keep changes surgical and focused
- `explorationRule` - Explore codebase before editing
- `gitCheckpointRule` - Commit after each change
- `debugRule` - Systematic debugging approach
- `completionRule` - **IMPORTANT**: Ensures agent calls `done()` when task is complete (prevents infinite loops)

### Browser Automation Configuration

**CRITICAL**: Always run browser automation in **headless mode** for better performance and reliability:

- When using browser tools, always specify headless mode in configuration
- Include explicit instructions in TASK string to use headless browser
- Example browser configuration: `headless: true`

## Execution Workflow

1. **Setup environment**:

   ```bash
   cd ralphs/[number]-feature-name
   cp ../28-previous-task/.env .env
   ```

2. **Run in background terminal**:

   ```bash
   pnpm tsx index.ts > .ralph-output.log 2>&1 &
   ```

3. **Monitor progress** (check periodically):

   ```bash
   # Initial checks: every 60 seconds
   sleep 60 && tail -n 50 .ralph-output.log && cat .progress.md

   # Later checks: every 3 minutes
   sleep 180 && tail -n 50 .ralph-output.log && cat .progress.md
   ```

4. **View traces** (for debugging):

   ```bash
   # Real-time trace monitoring
   tail -f .traces/trace-*.ndjson | jq .

   # Check stuck events
   cat .traces/trace-*.ndjson | jq 'select(.type == "stuck_detected")'
   ```

5. **Handle completion**:
   - ‚úÖ **Task passed**: Commit the changes on your current branch
   - ‚ùå **Task failed**: Reset changes and rerun with improved task prompt

## Best Practices

- **Repository structure clarity**: Always include a visual diagram of the repo structure in the TASK string so the LLM understands where it is and how to navigate
- **Progress tracking**: Ralph tracks progress in its own folder (`.progress.md`, `.brain/`)
- **Don't pre-create state files**: Let the agent create `.brain/` and `.progress.md` - provide templates in TASK string
- **Always enable traces**: Use `trace: true` for debugging and analysis
- **Only enable debug for issues**: Use `debug: false` by default, enable only when troubleshooting the runner itself
- **Browser headless mode**: Always run browser automation in headless mode for performance and reliability
- **One ralph at a time**: Create and run ralphs sequentially, not in parallel. This allows you to pivot the scope of your larger goal based on results and adapt your approach between tasks
- **Verification is critical**: Always include TypeScript verification functions that run after completion
- **Be specific in TASK**: Include exact file paths, working directories, code examples, and step-by-step navigation instructions
- **Documentation**: Ask ralphs to update docs, tests, and cursor rules as needed
- **Keep executing until completion**: Continue working through all tasks in your plan until the entire long-term goal is achieved. Don't stop after individual ralphs complete. Keep running sleeps commands to check progress.
